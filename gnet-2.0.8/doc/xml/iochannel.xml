<refentry id="gnet-iochannel">
<refmeta>
<refentrytitle role="top_of_page">IOChannel</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>GNET Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>IOChannel</refname>
<refpurpose>GIOChannel utility functions</refpurpose>
<!--[<xref linkend="desc" endterm="desc.title"/>]-->
</refnamediv>

<refsynopsisdiv role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>

#include &lt;gnet.h&gt;


<link linkend="GIOError">GIOError</link>            <link linkend="gnet-io-channel-writen">gnet_io_channel_writen</link>              (<link linkend="GIOChannel">GIOChannel</link> *channel,
                                                         <link linkend="gpointer">gpointer</link> buffer,
                                                         <link linkend="gsize">gsize</link> length,
                                                         <link linkend="gsize">gsize</link> *bytes_writtenp);
<link linkend="GIOError">GIOError</link>            <link linkend="gnet-io-channel-readn">gnet_io_channel_readn</link>               (<link linkend="GIOChannel">GIOChannel</link> *channel,
                                                         <link linkend="gpointer">gpointer</link> buffer,
                                                         <link linkend="gsize">gsize</link> length,
                                                         <link linkend="gsize">gsize</link> *bytes_readp);
<link linkend="GIOError">GIOError</link>            <link linkend="gnet-io-channel-readline">gnet_io_channel_readline</link>            (<link linkend="GIOChannel">GIOChannel</link> *channel,
                                                         <link linkend="gchar">gchar</link> *buffer,
                                                         <link linkend="gsize">gsize</link> length,
                                                         <link linkend="gsize">gsize</link> *bytes_readp);
<link linkend="GIOError">GIOError</link>            <link linkend="gnet-io-channel-readline-strdup">gnet_io_channel_readline_strdup</link>     (<link linkend="GIOChannel">GIOChannel</link> *channel,
                                                         <link linkend="gchar">gchar</link> **bufferp,
                                                         <link linkend="gsize">gsize</link> *bytes_readp);
</synopsis>
</refsynopsisdiv>









<refsect1 role="desc">
<title role="desc.title">Description</title>
<para>
The IOChannel module provides utility functions for reading from and
writing to GIOChannels.
</para>
</refsect1>

<refsect1 role="details">
<title role="details.title">Details</title>
<refsect2>
<title><anchor id="gnet-io-channel-writen" role="function"/>gnet_io_channel_writen ()</title>
<indexterm><primary>gnet_io_channel_writen</primary></indexterm><programlisting><link linkend="GIOError">GIOError</link>            gnet_io_channel_writen              (<link linkend="GIOChannel">GIOChannel</link> *channel,
                                                         <link linkend="gpointer">gpointer</link> buffer,
                                                         <link linkend="gsize">gsize</link> length,
                                                         <link linkend="gsize">gsize</link> *bytes_writtenp);</programlisting>
<para>
Writes all <parameter>length</parameter> bytes in <parameter>buffer</parameter> to <parameter>channel</parameter>.  If
<parameter>bytes_writtenp</parameter> is set, the number of bytes written is stored in
the integer it points to.  <parameter>bytes_writtenp</parameter> will be less than
<parameter>length</parameter> if the connection closed or an error occured.
</para>
<para>
This function is essentially a wrapper around <link linkend="g-io-channel-write"><function>g_io_channel_write()</function></link>.
The problem with <link linkend="g-io-channel-write"><function>g_io_channel_write()</function></link> is that it may not write all
the bytes and will return a short count even when there was not an
error.  This is rare, but possible, and often difficult to detect
when it does happen.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>channel</parameter>&nbsp;:</term>
<listitem><simpara> channel to write to
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>buffer</parameter>&nbsp;:</term>
<listitem><simpara> buffer to read from
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>length</parameter>&nbsp;:</term>
<listitem><simpara> length of <parameter>buffer</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>bytes_writtenp</parameter>&nbsp;:</term>
<listitem><simpara> pointer to integer in which to store the
  number of bytes written
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="G-IO-ERROR-NONE:CAPS"><literal>G_IO_ERROR_NONE</literal></link> if successful; something else otherwise.
The number of bytes written is stored in the integer pointed to by
<parameter>bytes_writtenp</parameter>.

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-io-channel-readn" role="function"/>gnet_io_channel_readn ()</title>
<indexterm><primary>gnet_io_channel_readn</primary></indexterm><programlisting><link linkend="GIOError">GIOError</link>            gnet_io_channel_readn               (<link linkend="GIOChannel">GIOChannel</link> *channel,
                                                         <link linkend="gpointer">gpointer</link> buffer,
                                                         <link linkend="gsize">gsize</link> length,
                                                         <link linkend="gsize">gsize</link> *bytes_readp);</programlisting>
<para>
Read exactly <parameter>length</parameter> bytes from <parameter>channel</parameter> into <parameter>buffer</parameter>.  If
<parameter>bytes_readp</parameter> is set, the number of bytes read is stored in the
integer it points to.  <parameter>bytes_readp</parameter> will be less than <parameter>length</parameter> if the
end-of-file was reached or an error occured.
</para>
<para>
This function is essentially a wrapper around <link linkend="g-io-channel-read"><function>g_io_channel_read()</function></link>.
The problem with <link linkend="g-io-channel-read"><function>g_io_channel_read()</function></link> is that it may not read all
the bytes requested and will return a short count even when there
was not an error (this is rare, but it can happen and is often
difficult to detect when it does).</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>channel</parameter>&nbsp;:</term>
<listitem><simpara> channel to read from
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>buffer</parameter>&nbsp;:</term>
<listitem><simpara> buffer to write to
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>length</parameter>&nbsp;:</term>
<listitem><simpara> length of the buffer
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>bytes_readp</parameter>&nbsp;:</term>
<listitem><simpara> pointer to integer for the function to store the 
number of of bytes read
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="G-IO-ERROR-NONE:CAPS"><literal>G_IO_ERROR_NONE</literal></link> if everything is ok; something else
otherwise.  Also, returns the number of bytes read by modifying the
integer pointed to by <parameter>bytes_readp</parameter>.

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-io-channel-readline" role="function"/>gnet_io_channel_readline ()</title>
<indexterm><primary>gnet_io_channel_readline</primary></indexterm><programlisting><link linkend="GIOError">GIOError</link>            gnet_io_channel_readline            (<link linkend="GIOChannel">GIOChannel</link> *channel,
                                                         <link linkend="gchar">gchar</link> *buffer,
                                                         <link linkend="gsize">gsize</link> length,
                                                         <link linkend="gsize">gsize</link> *bytes_readp);</programlisting>
<para>
Read a line from the channel.  The line will be NULL-terminated and
include the newline character.  If there is not enough room for the
line, the line is truncated to fit in the buffer.
</para>
<para>
Warnings:
</para>
<para>
1. If the buffer is full and the last character is not a newline,
the line was truncated.  Do not assume the buffer ends with a
newline.
</para>
<para>
2. <parameter>bytes_readp</parameter> is the number of bytes put in the buffer.  It
includes the terminating NULL character.
</para>
<para>
3. NULL characters can appear in the line before the terminating
NULL (e.g., "Hello world\0\n").  If this matters,
check the string length of the buffer against the bytes read.
</para>
<para>
I hope this isn't too confusing.  Usually the function works as you
expect it to if you have a big enough buffer.  If you have the
Stevens book, you should be familiar with the semantics.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>channel</parameter>&nbsp;:</term>
<listitem><simpara> channel to read from
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>buffer</parameter>&nbsp;:</term>
<listitem><simpara> buffer to write to
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>length</parameter>&nbsp;:</term>
<listitem><simpara> length of the buffer
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>bytes_readp</parameter>&nbsp;:</term>
<listitem><simpara> pointer to integer in which to store the 
  number of of bytes read
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="G-IO-ERROR-NONE:CAPS"><literal>G_IO_ERROR_NONE</literal></link> if everything is ok; something else
otherwise.  The number of bytes read is stored in the integer
pointed to by <parameter>bytes_readp</parameter> (this number includes the newline).  If
an error is returned, the contents of <parameter>buffer</parameter> and <parameter>bytes_readp</parameter> are
undefined.

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-io-channel-readline-strdup" role="function"/>gnet_io_channel_readline_strdup ()</title>
<indexterm><primary>gnet_io_channel_readline_strdup</primary></indexterm><programlisting><link linkend="GIOError">GIOError</link>            gnet_io_channel_readline_strdup     (<link linkend="GIOChannel">GIOChannel</link> *channel,
                                                         <link linkend="gchar">gchar</link> **bufferp,
                                                         <link linkend="gsize">gsize</link> *bytes_readp);</programlisting>
<para>
Read a line from the channel.  The line will be null-terminated and
include the newline character.  Similarly to g_strdup_printf, a
buffer large enough to hold the string will be allocated.
</para>
<para>
Warnings:
</para>
<para>
1. If the last character of the buffer is not a newline, the line
was truncated by EOF.  Do not assume the buffer ends with a
newline.
</para>
<para>
2. <parameter>bytes_readp</parameter> is actually the number of bytes put in the buffer.
It includes the terminating NULL character.
</para>
<para>
3. NULL characters can appear in the line before the terminating
null (e.g., "Hello world\0\n").  If this matters, check the string
length of the buffer against the bytes read.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>channel</parameter>&nbsp;:</term>
<listitem><simpara> channel to read from
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>bufferp</parameter>&nbsp;:</term>
<listitem><simpara> pointer to gchar* in which to store the new buffer
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>bytes_readp</parameter>&nbsp;:</term>
<listitem><simpara> pointer to integer in which to store the 
  number of of bytes read
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="G-IO-ERROR-NONE:CAPS"><literal>G_IO_ERROR_NONE</literal></link> if everything is ok; something else
otherwise.  The number of bytes read is stored in the integer
pointed to by <parameter>bytes_readp</parameter> (this number includes the newline).  The
data pointer is stored in the pointer pointed to by <parameter>bufferp</parameter>.  This
data is caller-owned.  If an error is returned, the contents of
<parameter>bufferp</parameter> and <parameter>bytes_readp</parameter> are undefined.

</simpara></listitem></varlistentry>
</variablelist></refsect2>

</refsect1>




</refentry>
