<refentry id="gnet-conn-http">
<refmeta>
<refentrytitle role="top_of_page">GConnHttp</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>GNET Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>GConnHttp</refname>
<refpurpose>HTTP connection object</refpurpose>
<!--[<xref linkend="desc" endterm="desc.title"/>]-->
</refnamediv>

<refsynopsisdiv role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>

#include &lt;gnet.h&gt;


                    <link linkend="GConnHttp">GConnHttp</link>;
enum                <link linkend="GConnHttpMethod">GConnHttpMethod</link>;
enum                <link linkend="GConnHttpError">GConnHttpError</link>;
enum                <link linkend="GConnHttpEventType">GConnHttpEventType</link>;
                    <link linkend="GConnHttpEvent">GConnHttpEvent</link>;
                    <link linkend="GConnHttpEventResolved">GConnHttpEventResolved</link>;
                    <link linkend="GConnHttpEventResponse">GConnHttpEventResponse</link>;
                    <link linkend="GConnHttpEventRedirect">GConnHttpEventRedirect</link>;
                    <link linkend="GConnHttpEventData">GConnHttpEventData</link>;
                    <link linkend="GConnHttpEventError">GConnHttpEventError</link>;
<link linkend="void">void</link>                (<link linkend="GConnHttpFunc">*GConnHttpFunc</link>)                    (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="GConnHttpEvent">GConnHttpEvent</link> *event,
                                                         <link linkend="gpointer">gpointer</link> user_data);
enum                <link linkend="GConnHttpHeaderFlags">GConnHttpHeaderFlags</link>;
<link linkend="GConnHttp">GConnHttp</link>*          <link linkend="gnet-conn-http-new">gnet_conn_http_new</link>                  (void);
<link linkend="gboolean">gboolean</link>            <link linkend="gnet-conn-http-set-uri">gnet_conn_http_set_uri</link>              (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         const <link linkend="gchar">gchar</link> *uri);
<link linkend="gboolean">gboolean</link>            <link linkend="gnet-conn-http-set-escaped-uri">gnet_conn_http_set_escaped_uri</link>      (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         const <link linkend="gchar">gchar</link> *uri);
<link linkend="gboolean">gboolean</link>            <link linkend="gnet-conn-http-set-header">gnet_conn_http_set_header</link>           (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         const <link linkend="gchar">gchar</link> *field,
                                                         const <link linkend="gchar">gchar</link> *value,
                                                         <link linkend="GConnHttpHeaderFlags">GConnHttpHeaderFlags</link> flags);
<link linkend="void">void</link>                <link linkend="gnet-conn-http-set-max-redirects">gnet_conn_http_set_max_redirects</link>    (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="guint">guint</link> num);
<link linkend="void">void</link>                <link linkend="gnet-conn-http-set-timeout">gnet_conn_http_set_timeout</link>          (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="guint">guint</link> timeout);
<link linkend="gboolean">gboolean</link>            <link linkend="gnet-conn-http-set-user-agent">gnet_conn_http_set_user_agent</link>       (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         const <link linkend="gchar">gchar</link> *agent);
<link linkend="gboolean">gboolean</link>            <link linkend="gnet-conn-http-set-method">gnet_conn_http_set_method</link>           (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="GConnHttpMethod">GConnHttpMethod</link> method,
                                                         const <link linkend="gchar">gchar</link> *post_data,
                                                         <link linkend="gsize">gsize</link> post_data_len);
<link linkend="gboolean">gboolean</link>            <link linkend="gnet-conn-http-set-main-context">gnet_conn_http_set_main_context</link>     (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="GMainContext">GMainContext</link> *context);
<link linkend="void">void</link>                <link linkend="gnet-conn-http-run-async">gnet_conn_http_run_async</link>            (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="GConnHttpFunc">GConnHttpFunc</link> func,
                                                         <link linkend="gpointer">gpointer</link> user_data);
<link linkend="gboolean">gboolean</link>            <link linkend="gnet-conn-http-run">gnet_conn_http_run</link>                  (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="GConnHttpFunc">GConnHttpFunc</link> func,
                                                         <link linkend="gpointer">gpointer</link> user_data);
<link linkend="gboolean">gboolean</link>            <link linkend="gnet-conn-http-steal-buffer">gnet_conn_http_steal_buffer</link>         (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="gchar">gchar</link> **buffer,
                                                         <link linkend="gsize">gsize</link> *length);
<link linkend="void">void</link>                <link linkend="gnet-conn-http-cancel">gnet_conn_http_cancel</link>               (<link linkend="GConnHttp">GConnHttp</link> *conn);
<link linkend="void">void</link>                <link linkend="gnet-conn-http-delete">gnet_conn_http_delete</link>               (<link linkend="GConnHttp">GConnHttp</link> *conn);
<link linkend="gboolean">gboolean</link>            <link linkend="gnet-http-get">gnet_http_get</link>                       (const <link linkend="gchar">gchar</link> *url,
                                                         <link linkend="gchar">gchar</link> **buffer,
                                                         <link linkend="gsize">gsize</link> *length,
                                                         <link linkend="guint">guint</link> *response);
</synopsis>
</refsynopsisdiv>









<refsect1 role="desc">
<title role="desc.title">Description</title>
<para>
A <link linkend="GConnHttp"><type>GConnHttp</type></link> represents a HTTP client connection. A <link linkend="GConnHttp"><type>GConnHttp</type></link>
is created directly by calling <link linkend="gnet-conn-http-new"><function>gnet_conn_http_new()</function></link>. After
that set the URI to retrieve using <link linkend="gnet-conn-http-set-uri"><function>gnet_conn_http_set_uri()</function></link>. 
A connection is made and the HTTP request sent only once 
either <link linkend="gnet-conn-http-run-async"><function>gnet_conn_http_run_async()</function></link> or <link linkend="gnet-conn-http-run"><function>gnet_conn_http_run()</function></link>
is called. Use the asynchroneous variant if you want the
function to return immediately and prefer to receive data
and status information in the background via the callback
function. <link linkend="gnet-conn-http-run-async"><function>gnet_conn_http_run_async()</function></link> assumes that there is
already a GLib main loop running (e.g. the Gtk main loop).
</para>

<para>
You can decide for yourself how much information you would
like to receive during the HTTP operation. All status 
information is communicated to the caller via the optional
callback function.
</para>

<para>
The easiest way to just retrieve some data via HTTP is to
use the convenience function <link linkend="gnet-http-get"><function>gnet_http_get()</function></link>.
</para>

<para>
Here is a small example how to retrieve a file with the
least amount of effort and error checking (this is 
more or less what <link linkend="gnet-http-get"><function>gnet_http_get()</function></link> does internally):
<example>
<title>Simple <structname>GConnHttp</structname> usage.</title>
<programlisting>
&hash;define GNET_EXPERIMENTAL
&hash;include &lt;gnet.h&gt;

void
fetch_and_print_url (const gchar *url)
{
  GConnHttp  *conn;
  
  conn = gnet_conn_http_new();
  
  gnet_conn_http_set_uri(conn, url);
  
  if (gnet_conn_http_run(conn, NULL, NULL))
  {
    gchar *buf;
    gsize  buflen;
    
    if (gnet_conn_http_steal_buffer(conn, &amp;buf, &amp;buflen))
    {
      g_print ("Received %%u bytes of data:\n%%s\n", buflen, buf);
      g_free(buf);
    }
  }
  
  gnet_conn_http_delete(conn);
}

  ...

  fetch_and_print_url ("http://www.google.com");
  
  ...

</programlisting>
</example>
</para>

<para>
<link linkend="GConnHttp"><type>GConnHttp</type></link> is still considered less mature than other parts of GNet, even
though it should generall work just fine. It just has not received as much
testing as other parts of GNet yet. You should not use it in production
level code without thoroughly testing it for your purposes. Because of that,
you need to define GNET_EXPERIMENTAL in your source code before including the
GNet headers (otherwise you will get compiler errors when trying to use it).
</para>
</refsect1>

<refsect1 role="details">
<title role="details.title">Details</title>
<refsect2>
<title><anchor id="GConnHttp" role="struct"/>GConnHttp</title>
<indexterm><primary>GConnHttp</primary></indexterm><programlisting>typedef struct _GConnHttp GConnHttp;</programlisting>
<para>
HTTP Connection. The entire GConnHttp struct is opaque and private.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="GConnHttpMethod" role="enum"/>enum GConnHttpMethod</title>
<indexterm><primary>GConnHttpMethod</primary></indexterm><programlisting>typedef enum
{
 GNET_CONN_HTTP_METHOD_GET,
 GNET_CONN_HTTP_METHOD_POST
} GConnHttpMethod;
</programlisting>
<para>
HTTP request method.  Use with <link linkend="gnet-conn-http-set-method"><function>gnet_conn_http_set_method()</function></link>.</para>
<para>

</para><variablelist role="enum">
<varlistentry>
<term><anchor id="GNET-CONN-HTTP-METHOD-GET:CAPS" role="constant"/><literal>GNET_CONN_HTTP_METHOD_GET</literal></term>
<listitem><simpara> HTTP GET method
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="GNET-CONN-HTTP-METHOD-POST:CAPS" role="constant"/><literal>GNET_CONN_HTTP_METHOD_POST</literal></term>
<listitem><simpara> HTTP POST method
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GConnHttpError" role="enum"/>enum GConnHttpError</title>
<indexterm><primary>GConnHttpError</primary></indexterm><programlisting>typedef enum
{
 GNET_CONN_HTTP_ERROR_UNSPECIFIED,
 GNET_CONN_HTTP_ERROR_PROTOCOL_UNSUPPORTED,
 GNET_CONN_HTTP_ERROR_HOSTNAME_RESOLUTION
} GConnHttpError;
</programlisting>
<para>
Error codes.  Used by <link linkend="GConnHttpEventError"><type>GConnHttpEventError</type></link>.  Note that 
   errors by the HTTP server will be communicated to the
   client via the <link linkend="GConnHttpEventResponse"><type>GConnHttpEventResponse</type></link> event.</para>
<para>

</para><variablelist role="enum">
<varlistentry>
<term><anchor id="GNET-CONN-HTTP-ERROR-UNSPECIFIED:CAPS" role="constant"/><literal>GNET_CONN_HTTP_ERROR_UNSPECIFIED</literal></term>
<listitem><simpara> connection error
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="GNET-CONN-HTTP-ERROR-PROTOCOL-UNSUPPORTED:CAPS" role="constant"/><literal>GNET_CONN_HTTP_ERROR_PROTOCOL_UNSUPPORTED</literal></term>
<listitem><simpara> unsupported protocol (ie. not http)
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="GNET-CONN-HTTP-ERROR-HOSTNAME-RESOLUTION:CAPS" role="constant"/><literal>GNET_CONN_HTTP_ERROR_HOSTNAME_RESOLUTION</literal></term>
<listitem><simpara> the hostname could not be resolved
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GConnHttpEventType" role="enum"/>enum GConnHttpEventType</title>
<indexterm><primary>GConnHttpEventType</primary></indexterm><programlisting>typedef enum
{
 GNET_CONN_HTTP_RESOLVED,           /* resolved host name           */
 GNET_CONN_HTTP_CONNECTED,          /* connected to host            */
 GNET_CONN_HTTP_RESPONSE,           /* got response (incl. headers) */
 GNET_CONN_HTTP_REDIRECT,           /* got redirect                 */
 GNET_CONN_HTTP_DATA_PARTIAL,       /* we got some data             */
 GNET_CONN_HTTP_DATA_COMPLETE,      /* we got all data              */
 GNET_CONN_HTTP_TIMEOUT,            /* the connection timed out     */
 GNET_CONN_HTTP_ERROR               /* GConnHttp problem            */
} GConnHttpEventType;
</programlisting>
<para>
GConnHttp event type.</para>
<para>

</para><variablelist role="enum">
<varlistentry>
<term><anchor id="GNET-CONN-HTTP-RESOLVED:CAPS" role="constant"/><literal>GNET_CONN_HTTP_RESOLVED</literal></term>
<listitem><simpara> the host name has been 
  resolved or host name resolution failed. The event
  structure will be a <link linkend="GConnHttpEventResolved"><type>GConnHttpEventResolved</type></link> structure
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="GNET-CONN-HTTP-CONNECTED:CAPS" role="constant"/><literal>GNET_CONN_HTTP_CONNECTED</literal></term>
<listitem><simpara> the TCP connection to 
  the HTTP server has been established
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="GNET-CONN-HTTP-RESPONSE:CAPS" role="constant"/><literal>GNET_CONN_HTTP_RESPONSE</literal></term>
<listitem><simpara> the HTTP server has sent 
  a response and response headers. The event
  structure will be a <link linkend="GConnHttpEventResponse"><type>GConnHttpEventResponse</type></link> structure
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="GNET-CONN-HTTP-REDIRECT:CAPS" role="constant"/><literal>GNET_CONN_HTTP_REDIRECT</literal></term>
<listitem><simpara> the HTTP server has sent 
  a redirect response. The event structure will be a
  <link linkend="GConnHttpEventRedirect"><type>GConnHttpEventRedirect</type></link> structure
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="GNET-CONN-HTTP-DATA-PARTIAL:CAPS" role="constant"/><literal>GNET_CONN_HTTP_DATA_PARTIAL</literal></term>
<listitem><simpara> data has been received.
  The buffer is caller-owned (ie. owned by GNet), but 
  may be emptied using <link linkend="gnet-conn-http-steal-buffer"><function>gnet_conn_http_steal_buffer()</function></link>. The
  event structure will be a <link linkend="GConnHttpEventData"><type>GConnHttpEventData</type></link> structure
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="GNET-CONN-HTTP-DATA-COMPLETE:CAPS" role="constant"/><literal>GNET_CONN_HTTP_DATA_COMPLETE</literal></term>
<listitem><simpara> data has been received
  in full.  The buffer is caller-owned (ie. owned by GNet), 
  but may be emptied using <link linkend="gnet-conn-http-steal-buffer"><function>gnet_conn_http_steal_buffer()</function></link>. The
  event structure will be a <link linkend="GConnHttpEventData"><type>GConnHttpEventData</type></link> structure
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="GNET-CONN-HTTP-TIMEOUT:CAPS" role="constant"/><literal>GNET_CONN_HTTP_TIMEOUT</literal></term>
<listitem><simpara> the connection timed out
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="GNET-CONN-HTTP-ERROR:CAPS" role="constant"/><literal>GNET_CONN_HTTP_ERROR</literal></term>
<listitem><simpara> <link linkend="GConnHttp"><type>GConnHttp</type></link> problem (not a server 
  error response). The event structure will be a 
  <link linkend="GConnHttpEventError"><type>GConnHttpEventError</type></link> structure
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GConnHttpEvent" role="struct"/>GConnHttpEvent</title>
<indexterm><primary>GConnHttpEvent</primary></indexterm><programlisting>typedef struct {
 GConnHttpEventType   type;           /* type of event (see above)         */
} GConnHttpEvent;
</programlisting>
<para>
GConnHttp Base Event.  Check event->type and then cast the event
  structure into the corresponding specialised event structure.</para>
<para>

</para><variablelist role="struct">
<varlistentry>
<term><link linkend="GConnHttpEventType">GConnHttpEventType</link>&nbsp;<structfield>type</structfield>;</term>
<listitem><simpara> event type
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GConnHttpEventResolved" role="struct"/>GConnHttpEventResolved</title>
<indexterm><primary>GConnHttpEventResolved</primary></indexterm><programlisting>typedef struct {
 GInetAddr           *ia;             /* GInetAddr of the host name        */
} GConnHttpEventResolved;
</programlisting>
<para>
GConnHttp Host Name Resolved Event.  Emitted when the host name has 
  been resolved to an IP address, primarily to give progress feedback 
  to the user. <parameter>ia</parameter> will be NULL if the host name could not be resolved.</para>
<para>

</para><variablelist role="struct">
<varlistentry>
<term><link linkend="GInetAddr">GInetAddr</link>&nbsp;*<structfield>ia</structfield>;</term>
<listitem><simpara> a <link linkend="GInetAddr"><type>GInetAddr</type></link> of the resolved host name.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GConnHttpEventResponse" role="struct"/>GConnHttpEventResponse</title>
<indexterm><primary>GConnHttpEventResponse</primary></indexterm><programlisting>typedef struct {
 guint                response_code;  /* response code, e.g. 200, or 404   */
 gchar              **header_fields;  /* NULL-terminated array of strings  */
 gchar              **header_values;  /* NULL-terminated array of strings  */
} GConnHttpEventResponse;
</programlisting>
<para>
Emitted when the server has sent a response and response headers.</para>
<para>

</para><variablelist role="struct">
<varlistentry>
<term><link linkend="guint">guint</link>&nbsp;<structfield>response_code</structfield>;</term>
<listitem><simpara> response code from the HTTP server (e.g. 200 or 404)
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="gchar">gchar</link>&nbsp;**<structfield>header_fields</structfield>;</term>
<listitem><simpara> array of header field strings, NULL-terminated
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="gchar">gchar</link>&nbsp;**<structfield>header_values</structfield>;</term>
<listitem><simpara> array of header value strings, NULL-terminated
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GConnHttpEventRedirect" role="struct"/>GConnHttpEventRedirect</title>
<indexterm><primary>GConnHttpEventRedirect</primary></indexterm><programlisting>typedef struct {
 guint                num_redirects;  /* number of redirects so far        */
 guint                max_redirects;  /* max. num. of redirects allowed    */
 gchar               *new_location;   /* redirect location if provided     */
 gboolean             auto_redirect;  /* FALSE if action is needed         */
} GConnHttpEventRedirect;
</programlisting>
<para>
Emitted when the server sends a redirect response.</para>
<para>

</para><variablelist role="struct">
<varlistentry>
<term><link linkend="guint">guint</link>&nbsp;<structfield>num_redirects</structfield>;</term>
<listitem><simpara> number of redirects so far
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="guint">guint</link>&nbsp;<structfield>max_redirects</structfield>;</term>
<listitem><simpara> maximum number of redirects allowed
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="gchar">gchar</link>&nbsp;*<structfield>new_location</structfield>;</term>
<listitem><simpara> redirect location, or NULL if not provided
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="gboolean">gboolean</link>&nbsp;<structfield>auto_redirect</structfield>;</term>
<listitem><simpara> FALSE if action by the client is needed. Set 
                 to FALSE to prevent automatic redirection
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GConnHttpEventData" role="struct"/>GConnHttpEventData</title>
<indexterm><primary>GConnHttpEventData</primary></indexterm><programlisting>typedef struct {
 guint64              content_length; /* set if available, otherwise 0     */
 guint64              data_received;  /* bytes received so far             */
 const gchar         *buffer;         /* buffer                            */
 gsize                buffer_length;  /* buffer length                     */
} GConnHttpEventData;
</programlisting>
<para>
Emitted when data has been received. Useful for progress feedback 
  to the user or to process data before all of it has been received.
  The client is responsible for emptying the buffer regularly when the 
  amount of data received or expected is larger than the amount that
  should be kept in memory (e.g. in the case of large binary files).</para>
<para>

</para><variablelist role="struct">
<varlistentry>
<term><link linkend="guint64">guint64</link>&nbsp;<structfield>content_length</structfield>;</term>
<listitem><simpara> set if available, otherwise 0
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="guint64">guint64</link>&nbsp;<structfield>data_received</structfield>;</term>
<listitem><simpara> total amount of data received so far
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>const&nbsp;<link linkend="gchar">gchar</link>&nbsp;*<structfield>buffer</structfield>;</term>
<listitem><simpara> buffer with data received so far. Use 
 <link linkend="gnet-conn-http-steal-buffer"><function>gnet_conn_http_steal_buffer()</function></link> to empty the buffer.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="gsize">gsize</link>&nbsp;<structfield>buffer_length</structfield>;</term>
<listitem><simpara> buffer length
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GConnHttpEventError" role="struct"/>GConnHttpEventError</title>
<indexterm><primary>GConnHttpEventError</primary></indexterm><programlisting>typedef struct {
 GConnHttpError       code;           /* error code                        */
 gchar               *message;        /* message (use for debugging only)  */
} GConnHttpEventError;
</programlisting>
<para>
Emitted when an error has occured. Note that HTTP server errors are
  communicated to the client by means of a <link linkend="GConnHttpEventResponse"><type>GConnHttpEventResponse</type></link> event.</para>
<para>

</para><variablelist role="struct">
<varlistentry>
<term><link linkend="GConnHttpError">GConnHttpError</link>&nbsp;<structfield>code</structfield>;</term>
<listitem><simpara> one of the <link linkend="GConnHttpError"><type>GConnHttpError</type></link> codes
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="gchar">gchar</link>&nbsp;*<structfield>message</structfield>;</term>
<listitem><simpara> clear-text error message (for debugging purposes only)
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GConnHttpFunc" role="function"/>GConnHttpFunc ()</title>
<indexterm><primary>GConnHttpFunc</primary></indexterm><programlisting><link linkend="void">void</link>                (*GConnHttpFunc)                    (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="GConnHttpEvent">GConnHttpEvent</link> *event,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Callback for <link linkend="GConnHttp"><type>GConnHttp</type></link>.
</para>
<para>
 Check event->type and then cast the event into the appropriate
  event structure. event->type will be one of
</para>
<para>
 <link linkend="GNET-CONN-HTTP-RESOLVED:CAPS"><literal>GNET_CONN_HTTP_RESOLVED</literal></link>: this event occurs when the host name
 has been resolved or host name resolution failed
</para>
<para>
 <link linkend="GNET-CONN-HTTP-CONNECTED:CAPS"><literal>GNET_CONN_HTTP_CONNECTED</literal></link>: the TCP connection to the 
 HTTP server has been established
</para>
<para>
 <link linkend="GNET-CONN-HTTP-RESPONSE:CAPS"><literal>GNET_CONN_HTTP_RESPONSE</literal></link>: the HTTP server has sent a response
 and response headers
</para>
<para>
 <link linkend="GNET-CONN-HTTP-REDIRECT:CAPS"><literal>GNET_CONN_HTTP_REDIRECT</literal></link>: the HTTP server has sent a redirect
 response
</para>
<para>
 <link linkend="GNET-CONN-HTTP-DATA-PARTIAL:CAPS"><literal>GNET_CONN_HTTP_DATA_PARTIAL</literal></link>: data has been read. The buffer is
 owned by GNet and you must not modify it or free it. You can
 take ownership of the buffer with <link linkend="gnet-conn-http-steal-buffer"><function>gnet_conn_http_steal_buffer()</function></link>
</para>
<para>
 <link linkend="GNET-CONN-HTTP-DATA-COMPLETE:CAPS"><literal>GNET_CONN_HTTP_DATA_COMPLETE</literal></link>: data has been received in full.
 The buffer is owned by GNet and you must not modify it or free 
 it. You can acquire ownership of the buffer by calling 
 <link linkend="gnet-conn-http-steal-buffer"><function>gnet_conn_http_steal_buffer()</function></link>
</para>
<para>
 <link linkend="GNET-CONN-HTTP-TIMEOUT:CAPS"><literal>GNET_CONN_HTTP_TIMEOUT</literal></link>: the connection timed out
</para>
<para>
 <link linkend="GNET-CONN-HTTP-ERROR:CAPS"><literal>GNET_CONN_HTTP_ERROR</literal></link>: <link linkend="GConnHttp"><type>GConnHttp</type></link> problem (not a server error response)</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&nbsp;:</term>
<listitem><simpara> <link linkend="GConnHttp"><type>GConnHttp</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>event</parameter>&nbsp;:</term>
<listitem><simpara> event (caller-owned, do not free)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara> user data specified in <link linkend="gnet-conn-http-run"><function>gnet_conn_http_run()</function></link> 
             or <link linkend="gnet-conn-http-run-async"><function>gnet_conn_http_run_async()</function></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GConnHttpHeaderFlags" role="enum"/>enum GConnHttpHeaderFlags</title>
<indexterm><primary>GConnHttpHeaderFlags</primary></indexterm><programlisting>typedef enum
{
  GNET_CONN_HTTP_FLAG_SKIP_HEADER_CHECK  = 1
} GConnHttpHeaderFlags;
</programlisting>
<para>
Flags for <link linkend="gnet-conn-http-set-header"><function>gnet_conn_http_set_header()</function></link>.</para>
<para>

</para><variablelist role="enum">
<varlistentry>
<term><anchor id="GNET-CONN-HTTP-FLAG-SKIP-HEADER-CHECK:CAPS" role="constant"/><literal>GNET_CONN_HTTP_FLAG_SKIP_HEADER_CHECK</literal></term>
<listitem><simpara> do not check whether
  the header is a standard header
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-conn-http-new" role="function"/>gnet_conn_http_new ()</title>
<indexterm><primary>gnet_conn_http_new</primary></indexterm><programlisting><link linkend="GConnHttp">GConnHttp</link>*          gnet_conn_http_new                  (void);</programlisting>
<para>
Creates a <link linkend="GConnHttp"><type>GConnHttp</type></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> a <link linkend="GConnHttp"><type>GConnHttp</type></link>.

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-conn-http-set-uri" role="function"/>gnet_conn_http_set_uri ()</title>
<indexterm><primary>gnet_conn_http_set_uri</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            gnet_conn_http_set_uri              (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         const <link linkend="gchar">gchar</link> *uri);</programlisting>
<para>
Sets the URI to GET or POST, e.g. http://www.foo.com/bar.html. <parameter>uri</parameter> is
 assumed to be unescaped, so all special URI characters will be escaped.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GConnHttp"><type>GConnHttp</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>uri</parameter>&nbsp;:</term>
<listitem><simpara> URI string
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> TRUE if the URI has been accepted.

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-conn-http-set-escaped-uri" role="function"/>gnet_conn_http_set_escaped_uri ()</title>
<indexterm><primary>gnet_conn_http_set_escaped_uri</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            gnet_conn_http_set_escaped_uri      (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         const <link linkend="gchar">gchar</link> *uri);</programlisting>
<para>
Sets the URI to GET or POST, e.g. http://www.foo.com/My%<link linkend="20Documents"><literal>20Documents</literal></link>/bar.txt</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GConnHttp"><type>GConnHttp</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>uri</parameter>&nbsp;:</term>
<listitem><simpara> URI string with special characters already escaped
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> TRUE if the URI has been accepted.

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-conn-http-set-header" role="function"/>gnet_conn_http_set_header ()</title>
<indexterm><primary>gnet_conn_http_set_header</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            gnet_conn_http_set_header           (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         const <link linkend="gchar">gchar</link> *field,
                                                         const <link linkend="gchar">gchar</link> *value,
                                                         <link linkend="GConnHttpHeaderFlags">GConnHttpHeaderFlags</link> flags);</programlisting>
<para>
Set header field to send with the HTTP request.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GConnHttp"><type>GConnHttp</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>field</parameter>&nbsp;:</term>
<listitem><simpara> a header field, e.g. "Accept"
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>value</parameter>&nbsp;:</term>
<listitem><simpara> the header field value, e.g. "text/html"
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>flags</parameter>&nbsp;:</term>
<listitem><simpara> one or more flags of <link linkend="GConnHttpHeaderFlags"><type>GConnHttpHeaderFlags</type></link>, or 0
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> TRUE if the header field has been set or changed

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-conn-http-set-max-redirects" role="function"/>gnet_conn_http_set_max_redirects ()</title>
<indexterm><primary>gnet_conn_http_set_max_redirects</primary></indexterm><programlisting><link linkend="void">void</link>                gnet_conn_http_set_max_redirects    (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="guint">guint</link> num);</programlisting>
<para>
Sets the maximum allowed number of automatic redirects.
  Note that the HTTP protocol specification (RFC2616) specifies 
  occasions where the client must not redirect automatically 
  without user intervention. In those cases, no automatic redirect
  will be performed, even if the limit has not been reached yet.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GConnHttp"><type>GConnHttp</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>num</parameter>&nbsp;:</term>
<listitem><simpara> the maximum number of allowed automatic redirects
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-conn-http-set-timeout" role="function"/>gnet_conn_http_set_timeout ()</title>
<indexterm><primary>gnet_conn_http_set_timeout</primary></indexterm><programlisting><link linkend="void">void</link>                gnet_conn_http_set_timeout          (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="guint">guint</link> timeout);</programlisting>
<para>
Sets a timeout on the http connection.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GConnHttp"><type>GConnHttp</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>timeout</parameter>&nbsp;:</term>
<listitem><simpara> timeout in milliseconds
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-conn-http-set-user-agent" role="function"/>gnet_conn_http_set_user_agent ()</title>
<indexterm><primary>gnet_conn_http_set_user_agent</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            gnet_conn_http_set_user_agent       (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         const <link linkend="gchar">gchar</link> *agent);</programlisting>
<para>
Convenience function. Wraps <link linkend="gnet-conn-http-set-header"><function>gnet_conn_http_set_header()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GConnHttp"><type>GConnHttp</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>agent</parameter>&nbsp;:</term>
<listitem><simpara> the user agent string to send (will be supplemented by a GNet
         version number comment)
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> TRUE if the user agent string has been changed.

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-conn-http-set-method" role="function"/>gnet_conn_http_set_method ()</title>
<indexterm><primary>gnet_conn_http_set_method</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            gnet_conn_http_set_method           (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="GConnHttpMethod">GConnHttpMethod</link> method,
                                                         const <link linkend="gchar">gchar</link> *post_data,
                                                         <link linkend="gsize">gsize</link> post_data_len);</programlisting>
<para>
Sets the HTTP request method. Default is the GET method.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GConnHttp"><type>GConnHttp</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>method</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GConnHttpMethod"><type>GConnHttpMethod</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>post_data</parameter>&nbsp;:</term>
<listitem><simpara> post data to send with POST method, or NULL
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>post_data_len</parameter>&nbsp;:</term>
<listitem><simpara> the length of the post data to send with POST method, or 0
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> TRUE if the method has been changed successfully.

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-conn-http-set-main-context" role="function" condition="since:2.0.8"/>gnet_conn_http_set_main_context ()</title>
<indexterm role="2.0.8"><primary>gnet_conn_http_set_main_context</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            gnet_conn_http_set_main_context     (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="GMainContext">GMainContext</link> *context);</programlisting>
<para>
Sets the GLib <link linkend="GMainContext"><type>GMainContext</type></link> to use for asynchronous operations. You should
 call this function right after you create <parameter>conn</parameter>. You must not call this
 function after the actual connection process has started.
</para>
<para>
 You are very unlikely to ever need this function.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GConnHttp"><type>GConnHttp</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GMainContext"><type>GMainContext</type></link>, or NULL to use the default GLib main context
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> TRUE on success, FALSE on failure.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.0.8
</para></refsect2>
<refsect2>
<title><anchor id="gnet-conn-http-run-async" role="function"/>gnet_conn_http_run_async ()</title>
<indexterm><primary>gnet_conn_http_run_async</primary></indexterm><programlisting><link linkend="void">void</link>                gnet_conn_http_run_async            (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="GConnHttpFunc">GConnHttpFunc</link> func,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Starts connecting and sending the specified http request. Will 
  return immediately. Assumes there is an existing and running 
  default Gtk/GLib/Gnome main loop.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GConnHttp"><type>GConnHttp</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>func</parameter>&nbsp;:</term>
<listitem><simpara> callback function to communicate progress and errors, or NULL
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara> user data to pass to callback function, or NULL
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-conn-http-run" role="function"/>gnet_conn_http_run ()</title>
<indexterm><primary>gnet_conn_http_run</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            gnet_conn_http_run                  (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="GConnHttpFunc">GConnHttpFunc</link> func,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Starts connecting and sending the specified http request. Will 
  return once the operation has finished and either an error has 
  occured, or the data has been received in full.
</para>
<para>
  This function will run its own main loop in the default GLib main context
  (or the user-specified main context, if one was specified with
  <link linkend="gnet-conn-http-set-main-context"><function>gnet_conn_http_set_main_context()</function></link>), which means that if your application
  is based on Gtk+ or sets up GLib timeouts or idle callbacks, it is
  possible that those callback functions are invoked while you are waiting
  for <link linkend="gnet-conn-http-run"><function>gnet_conn_http_run()</function></link> to return. This means you shouldn't make
  assumptions about any state you set up before calling this function,
  because it might have been changed again from within a callback in the
  mean time (if this can happen or not depends on your callbacks and what
  they do of course).</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GConnHttp"><type>GConnHttp</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>func</parameter>&nbsp;:</term>
<listitem><simpara> callback function to communicate progress and errors, or NULL
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara> user data to pass to callback function, or NULL
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> TRUE if no error occured before connecting

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-conn-http-steal-buffer" role="function"/>gnet_conn_http_steal_buffer ()</title>
<indexterm><primary>gnet_conn_http_steal_buffer</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            gnet_conn_http_steal_buffer         (<link linkend="GConnHttp">GConnHttp</link> *conn,
                                                         <link linkend="gchar">gchar</link> **buffer,
                                                         <link linkend="gsize">gsize</link> *length);</programlisting>
<para>
Empties the current buffer and returns the contents. The 
  main purpose of this function is to make it possible to 
  just use <link linkend="gnet-conn-http-run"><function>gnet_conn_http_run()</function></link>, check its return value, and 
  then get the buffer data without having to install a 
  callback function. Also needed to empty the buffer regularly
  while receiving large amounts of data.
</para>
<para>
 The caller (you) needs to free the buffer with <link linkend="g-free"><function>g_free()</function></link> when done.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GConnHttp"><type>GConnHttp</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>buffer</parameter>&nbsp;:</term>
<listitem><simpara> where to store a pointer to the buffer data
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>length</parameter>&nbsp;:</term>
<listitem><simpara> where to store the length of the buffer data
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> TRUE if buffer and length have been set

</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-conn-http-cancel" role="function"/>gnet_conn_http_cancel ()</title>
<indexterm><primary>gnet_conn_http_cancel</primary></indexterm><programlisting><link linkend="void">void</link>                gnet_conn_http_cancel               (<link linkend="GConnHttp">GConnHttp</link> *conn);</programlisting>
<para>
Cancels the current http transfer (if any) and makes
  <link linkend="gnet-conn-http-run"><function>gnet_conn_http_run()</function></link> return immediately. Will do nothing
  if the transfer was started with <link linkend="gnet-conn-http-run-async"><function>gnet_conn_http_run_async()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GConnHttp"><type>GConnHttp</type></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-conn-http-delete" role="function"/>gnet_conn_http_delete ()</title>
<indexterm><primary>gnet_conn_http_delete</primary></indexterm><programlisting><link linkend="void">void</link>                gnet_conn_http_delete               (<link linkend="GConnHttp">GConnHttp</link> *conn);</programlisting>
<para>
Deletes a <link linkend="GConnHttp"><type>GConnHttp</type></link> and frees all associated resources.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>conn</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GConnHttp"><type>GConnHttp</type></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="gnet-http-get" role="function"/>gnet_http_get ()</title>
<indexterm><primary>gnet_http_get</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            gnet_http_get                       (const <link linkend="gchar">gchar</link> *url,
                                                         <link linkend="gchar">gchar</link> **buffer,
                                                         <link linkend="gsize">gsize</link> *length,
                                                         <link linkend="guint">guint</link> *response);</programlisting>
<para>
Convenience function that just retrieves
  the provided URI without the need to 
  set up a full <link linkend="GConnHttp"><type>GConnHttp</type></link>. Uses 
  <link linkend="gnet-conn-http-run"><function>gnet_conn_http_run()</function></link> internally.
</para>
<para>
 Caller (you) needs to free the buffer with <link linkend="g-free"><function>g_free()</function></link> when
  no longer needed.
</para>
<para>
 This function will run its own main loop in the default GLib main context,
  which means that if your application is based on Gtk+ or sets up GLib
  timeouts or idle callbacks, it is possible that those callback functions
  are invoked while you are waiting for <link linkend="gnet-http-get"><function>gnet_http_get()</function></link> to return. This
  means you shouldn't make assumptions about any state you set up before
  calling this function, because it might have been changed again from
  within a callback in the mean time (if this can happen or not depends on
  your callbacks and what they do of course).</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>url</parameter>&nbsp;:</term>
<listitem><simpara> a URI, e.g. http://www.foo.com
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>buffer</parameter>&nbsp;:</term>
<listitem><simpara> where to store a pointer to the data retrieved
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>length</parameter>&nbsp;:</term>
<listitem><simpara> where to store the length of the data retrieved
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>response</parameter>&nbsp;:</term>
<listitem><simpara> where to store the last HTTP response code 
 received from the HTTP server, or NULL.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> TRUE if <parameter>buffer</parameter>, <parameter>length</parameter> and <parameter>response</parameter> are set,
  otherwise FALSE.

</simpara></listitem></varlistentry>
</variablelist></refsect2>

</refsect1>




</refentry>
